<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>序列化相关 | 淡定独行</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="序列化使用序列化类的私有方法巧妙解决部分属性持久化问题 业务场景  一个计税系统和人力资源系统（HR系统）通过RMI（Remote Method Invocation，远程方法调用）对接，计税系统需要从HR系统获得人员的姓名和基本工资，以作为纳税的依据，而HR系统的工资分为两部分：基本工资和绩效工资，基本工资没什么秘密，根据工作岗位和年限自己都可以计算出来，但绩效工资却是保密的，不能泄露到外系统">
<meta name="keywords" content="JAVA,笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="序列化相关">
<meta property="og:url" content="http://www.xhlcode.cn/2018/02/10/序列化相关/index.html">
<meta property="og:site_name" content="淡定独行">
<meta property="og:description" content="序列化使用序列化类的私有方法巧妙解决部分属性持久化问题 业务场景  一个计税系统和人力资源系统（HR系统）通过RMI（Remote Method Invocation，远程方法调用）对接，计税系统需要从HR系统获得人员的姓名和基本工资，以作为纳税的依据，而HR系统的工资分为两部分：基本工资和绩效工资，基本工资没什么秘密，根据工作岗位和年限自己都可以计算出来，但绩效工资却是保密的，不能泄露到外系统">
<meta property="og:locale" content="zh_Hans">
<meta property="og:updated_time" content="2019-01-17T06:49:45.197Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="序列化相关">
<meta name="twitter:description" content="序列化使用序列化类的私有方法巧妙解决部分属性持久化问题 业务场景  一个计税系统和人力资源系统（HR系统）通过RMI（Remote Method Invocation，远程方法调用）对接，计税系统需要从HR系统获得人员的姓名和基本工资，以作为纳税的依据，而HR系统的工资分为两部分：基本工资和绩效工资，基本工资没什么秘密，根据工作岗位和年限自己都可以计算出来，但绩效工资却是保密的，不能泄露到外系统">
  
    <link rel="alternate" href="/atom.xml" title="淡定独行" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">淡定独行</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.xhlcode.cn"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-序列化相关" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/10/序列化相关/" class="article-date">
  <time datetime="2018-02-10T02:36:00.000Z" itemprop="datePublished">2018-02-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      序列化相关
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="使用序列化类的私有方法巧妙解决部分属性持久化问题"><a href="#使用序列化类的私有方法巧妙解决部分属性持久化问题" class="headerlink" title="使用序列化类的私有方法巧妙解决部分属性持久化问题"></a>使用序列化类的私有方法巧妙解决部分属性持久化问题</h3><blockquote>
<p>业务场景</p>
<blockquote>
<p>一个计税系统和人力资源系统（HR系统）通过RMI（Remote Method Invocation，远程方法调用）对接，计税系统需要从HR系统获得人员的姓名和基本工资，以作为纳税的依据，而HR系统的工资分为两部分：基本工资和绩效工资，基本工资没什么秘密，根据工作岗位和年限自己都可以计算出来，但绩效工资却是保密的，不能泄露到外系统</p>
</blockquote>
</blockquote>
<h4 id="方案-1-transient关键字"><a href="#方案-1-transient关键字" class="headerlink" title="方案(1) transient关键字"></a>方案(1) transient关键字</h4><ul>
<li>在bonus前加上transient关键字,这是一个方法，但不是一个好方法，加上transient关键字就标志着Salary类失去了分布式部署的功能，它可是HR系统最核心的类了，一旦遭遇性能瓶颈，想再实现分布式部署就不可能了，<strong>此方案否定</strong>。</li>
</ul>
<h4 id="方案-2-新增业务对象"><a href="#方案-2-新增业务对象" class="headerlink" title="方案(2) 新增业务对象"></a>方案(2) 新增业务对象</h4><ul>
<li>增加一个Person4Tax类，完全为计税系统服务，就是说它只有两个属性：姓名和基本工资。符合开闭原则，而且对原系统也没有侵入性，只是增加了工作量而已。这是个方法，但<strong>不是最优方法</strong>。<h4 id="方案-3-请求端过滤"><a href="#方案-3-请求端过滤" class="headerlink" title="方案(3) 请求端过滤"></a>方案(3) 请求端过滤</h4></li>
<li>在计税系统获得Person对象后，过滤掉Salary的bonus属性，方案可行但不合规矩，因为HR系统中的Salary类安全性竟然让外系统（计税系统）来承担，<strong>设计严重失职</strong>。<h4 id="方案-4-变更传输契约"><a href="#方案-4-变更传输契约" class="headerlink" title="方案(4) 变更传输契约"></a>方案(4) 变更传输契约</h4></li>
<li>例如改用XML传输，或者重建一个Web Service服务。可以做，但<strong>成本太高</strong>。</li>
</ul>
<h4 id="优秀方案"><a href="#优秀方案" class="headerlink" title="优秀方案"></a>优秀方案</h4><ul>
<li>实现了Serializable接口的类可以实现两个私有方法：writeObject和readObject，以影响和控制序列化和反序列化的过程。 如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Salary</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2140234769839131214L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 脚本工资</span></span><br><span class="line">    <span class="keyword">private</span> Double basePay;</span><br><span class="line">	<span class="comment">// 绩效工资</span></span><br><span class="line">    <span class="keyword">private</span> Double bonus;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Salary</span><span class="params">(Double basePay, Double bonus)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.basePay = basePay;</span><br><span class="line">        <span class="keyword">this</span>.bonus = bonus;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略 get set 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2092465505451534820L</span>;</span><br><span class="line">	<span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 绩效</span></span><br><span class="line">    <span class="keyword">private</span>  Salary salary;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name, Salary salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//序列化委托方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        out.defaultWriteObject();</span><br><span class="line">        out.writeDouble(salary.getBasePay());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 反序列化委托方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream in)</span> <span class="keyword">throws</span> IOException,ClassNotFoundException </span>&#123;</span><br><span class="line">        in.defaultReadObject();</span><br><span class="line">        salary = <span class="keyword">new</span> Salary(<span class="keyword">new</span> Double(<span class="number">0</span>),in.readDouble());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Salary salary = <span class="keyword">new</span> Salary(<span class="keyword">new</span> Double(<span class="number">4000</span>),<span class="keyword">new</span> Double(<span class="number">5000</span>));</span><br><span class="line">    People people = <span class="keyword">new</span> People(<span class="string">"zhangsan"</span>, salary);</span><br><span class="line">    System.out.println(JSONObject.toJSONString(people));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] data = SerializationUtils.serialize(people);</span><br><span class="line">    People result = (People)SerializationUtils.deserialize(data);</span><br><span class="line">    System.out.println(JSONObject.toJSONString(result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>打印结果<br>{“name”:”zhangsan”,”salary”:{“basePay”:4000.0,”bonus”:5000.0}}<br>{“name”:”zhangsan”,”salary”:{“basePay”:0.0,”bonus”:4000.0}}</p>
</blockquote>
<h3 id="使用序列化实现对象的拷贝"><a href="#使用序列化实现对象的拷贝" class="headerlink" title="使用序列化实现对象的拷贝"></a>使用序列化实现对象的拷贝</h3><blockquote>
<p>业务场景</p>
<blockquote>
<p>如果一个项目中有大量的对象是通过拷贝生成的，那我们该如何处理？每个类都写一个clone方法，并且还要深拷贝？想想看这是何等巨大的工作量呀，是否有更好的方法呢？</p>
</blockquote>
</blockquote>
<ul>
<li>其实，可以通过序列化方式来处理，在内存中通过字节流的拷贝来实现，也就是把母对象写到一个字节流中，再从字节流中将其读出来，这样就可以重建一个新对象了，该新对象与母对象之间不存在引用共享的问题，也就相当于深拷贝了一个新对象，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneUtils</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Serializable&gt; <span class="function">T <span class="title">clone</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        T cloneObj = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 读取对象字节数据</span></span><br><span class="line">            ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">            oos.writeObject(obj);</span><br><span class="line">            oos.close();</span><br><span class="line">            <span class="comment">// 分配内存   写入原始对象 生成新对象</span></span><br><span class="line">            ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">            cloneObj= (T)ois.readObject();</span><br><span class="line">            ois.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneObj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此工具类要求被拷贝的对象必须<strong>实现Serializable接口</strong>，否则是没办法拷贝的（当然，使用反射那是另外一种技巧） 用此方法需要注意两点:</p>
<ul>
<li>对象的内部属性都是可序列化的<br>  如果有内部属性不可序列化，则会抛出序列化异常，这会让调试者很纳闷：生成一个对象怎么会出现序列化异常呢？从这一点来考虑，也需要把CloneUtils工具的异常进行细化处理。</li>
<li>注意方法和属性的特殊修饰符<br>  比如final、static变量的序列化问题会被引入到对象拷贝中来（参考第1章），这点需要特别注意，同时transient变量（瞬态变量，不进行序列化的变量）也会影响到拷贝的效果。</li>
</ul>
<p>当然，采用序列化方式拷贝时还有一个更简单的办法，即<strong>使用Apache下的commons工具包中的SerializationUtils类</strong>，直接使用更加简洁方便。</p>
<h2 id="边界-边界-还是边界"><a href="#边界-边界-还是边界" class="headerlink" title="边界 边界 还是边界"></a>边界 边界 还是边界</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 边界测试() &#123;</span><br><span class="line">    Integer intMaxNum= <span class="number">2147483647</span>;</span><br><span class="line">    intMaxNum += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> limit = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 超过边界  判断失效</span></span><br><span class="line">    <span class="keyword">if</span>(intMaxNum &lt; limit) &#123;</span><br><span class="line">        System.out.println(<span class="string">"数字"</span>+intMaxNum+<span class="string">"小于"</span> + limit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果<br>数字-2147483648小于10</p>
</blockquote>
<h2 id="莫让四舍五入亏了一方"><a href="#莫让四舍五入亏了一方" class="headerlink" title="莫让四舍五入亏了一方"></a>莫让四舍五入亏了一方</h2><blockquote>
<p>四舍五入。四舍五入是一种近似精确的计算方法，在Java5之前，我们一般是通过使用Math.round来获得指定精度的整数或小数的，这种方法使用非常广泛，<br>代码如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"10.5近似值："</span> + Math.round(<span class="number">10.5</span>));</span><br><span class="line">    System.out.println(<span class="string">"-10.5近似值："</span> + Math.round(-<span class="number">10.5</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果<br>10.5近似值：11<br>-10.5近似值：-10</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是四舍五入的经典案例，也是初级面试官很乐意选择的考题，绝对值相同的两个数字，近似值为什么就不同了呢？这是由Math.round采用的舍入规则所决定的（采用的是正无穷方向舍入规则，后面会讲解）。我们知道四舍五入是有误差的：其误差值是舍入位的一半。<br>我们以舍入运用最频繁的银行利息计算为例来阐述该问题。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们知道银行的盈利渠道主要是利息差，从储户手里收拢资金，然后放贷出去，其间的利息差额便是所获得的利润。对一个银行来说，对付给储户的利息的计算非常频繁，人民银行规定每个季度末月的20日为银行结息日，一年有4次的结息日。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;场景介绍完毕，我们回过头来看四舍五入，小于5的数字被舍去，大于等于5的数字进位后舍去，由于所有位上的数字都是自然计算出来的，按照概率计算可知，被舍入的数字均匀分布在0到9之间，下面以10笔存款利息计算作为模型，以银行家的身份来思考这个算法：</p>
<ul>
<li>四舍。舍弃的数值：0.000、0.001、0.002、0.003、0.004，因为是舍弃的，对银行家来说，就不用付款给储户了，那每舍弃一个数字就会赚取相应的金额：0.000、0.001、0.002、0.003、0.004。</li>
<li>五入。进位的数值：0.005、0.006、0.007、0.008、0.009，因为是进位，对银行家来说，每进一位就会多付款给储户，也就是亏损了，那亏损部分就是其对应的10进制补数：0.005、0.004、0.003、0.002、0.001。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为舍弃和进位的数字是在0到9之间均匀分布的，所以对于银行家来说，每10笔存款的利息因采用四舍五入而获得的盈利是：<br><strong>0.000+0.001+0.002+0.003+0.004-0.005-0.004-0.003-0.002-0.001=-0.005</strong> 也就是说，每10笔的利息计算中就损失0.005元，即每笔利息计算损失0.0005元，这对一家有5千万储户的银行来说（对国内的银行来说，5千万是个很小的数字），每年仅仅因为四舍五入的误差而损失的金额是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//银行账户数量，5千万</span></span><br><span class="line">    <span class="keyword">int</span> accountNum =<span class="number">5000</span>*<span class="number">10000</span>;</span><br><span class="line">    <span class="comment">//按照人行的规定，每个季度末月的20日为银行结息日</span></span><br><span class="line">    <span class="keyword">double</span> cost=<span class="number">0.0005</span>*accountNum*<span class="number">4</span>;</span><br><span class="line">    System.out.println(<span class="string">"银行每年损失的金额："</span>+cost);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果<br>银行每年损失的金额：100000.0</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;即，每年因为一个算法误差就损失了10万元，事实上以上的假设条件都是非常保守的，实际情况可能损失得更多。那各位可能要说了，银行还要放贷呀，放出去这笔计算误差不就抵消掉了吗？不会抵销，银行的贷款数量是非常有限的，其数量级根本没有办法和存款相比。<br>这个算法误差是由美国银行家发现的（那可是私人银行，钱是自己的，白白损失了可不行），并且对此提出了一个修正算法，叫做银行家舍入（Banker’s Round）的近似算法，其规则如下：</p>
<ul>
<li>舍去位的数值小于5时，直接舍去；</li>
<li>舍去位的数值大于等于6时，进位后舍去；</li>
<li>当舍去位的数值等于5时，分两种情况：5后面还有其他数字（非0），则进位后舍去；若5后面是0（即5是最后一个数字），则根据5前一位数的奇偶性来判断是否需要进位，奇数进位，偶数舍去。</li>
</ul>
<p>以上规则汇总成一句话：</p>
<blockquote>
<p>四舍六入五考虑，五后非零就进一，五后为零看奇偶，五前为偶应舍去，五前为奇要进一。</p>
</blockquote>
<p>我们举例说明，取2位精度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">round(10.5551)=10.56</span><br><span class="line">round(10.555)=10.56</span><br><span class="line">round(10.545)=10.54</span><br></pre></td></tr></table></figure></p>
<p>要在Java5以上的版本中使用银行家的舍入法则非常简单，直接使用RoundingMode类提供的Round模式即可，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//存款</span></span><br><span class="line">    BigDecimal d=<span class="keyword">new</span> BigDecimal(<span class="number">888888</span>);</span><br><span class="line">    <span class="comment">//月利率，乘3计算季利率</span></span><br><span class="line">    BigDecimal r=<span class="keyword">new</span> BigDecimal(<span class="number">0.001875</span>*<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//计算利息</span></span><br><span class="line">    BigDecimal i=d.multiply(r).setScale(<span class="number">2</span>,RoundingMode.HALF_EVEN);</span><br><span class="line">    System.out.println(<span class="string">"季利息是："</span>+i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果<br>季利息是：4999.99</p>
</blockquote>
<p>在上面的例子中，我们使用了BigDecimal类，并且采用setScale方法设置了精度，同时传递了一个RoundingMode.HALF_EVEN参数表示使用银行家舍入法则进行近似计算，BigDecimal和RoundingMode是一个绝配，想要采用什么舍入模式使用RoundingMode设置即可。目前Java支持以下七种舍入方式：</p>
<ul>
<li>ROUND_UP：远离零方向舍入。<br>向远离0的方向舍入，也就是说，向绝对值最大的方向舍入，只要舍弃位非0即进位。</li>
<li>ROUND_DOWN：趋向零方向舍入。<br>向0方向靠拢，也就是说，向绝对值最小的方向输入，注意：所有的位都舍弃，不存在进位情况。</li>
<li>ROUND_CEILING：向正无穷方向舍入。<br>向正最大方向靠拢，如果是正数，舍入行为类似于ROUND_UP；如果为负数，则舍入行为类似于ROUND_DOWN。注意：Math.round方法使用的即为此模式。</li>
<li>ROUND_FLOOR：向负无穷方向舍入。<br>向负无穷方向靠拢，如果是正数，则舍入行为类似于ROUND_DOWN；如果是负数，则舍入行为类似于ROUND_UP。</li>
<li>HALF_UP：最近数字舍入（5进）。<br>这就是我们最最经典的四舍五入模式。</li>
<li>HALF_DOWN：最近数字舍入（5舍）。<br>在四舍五入中，5是进位的，而在HALF_DOWN中却是舍弃不进位。</li>
<li>HALF_EVEN：银行家算法。<br>在普通的项目中舍入模式不会有太多影响，可以直接使用Math.round方法，但在大量与货币数字交互的项目中，一定要选择好近似的计算模式，尽量减少因算法不同而造成的损失。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.xhlcode.cn/2018/02/10/序列化相关/" data-id="cjr09rljz0001ju50jf6zrsed" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/02/12/Java 8 中的 Streams API 详解/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Java 8 中的 Streams API 详解
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA/">JAVA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/笔记/">笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JAVA/" style="font-size: 10px;">JAVA</a> <a href="/tags/笔记/" style="font-size: 10px;">笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/01/17/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2018/02/12/Java 8 中的 Streams API 详解/">Java 8 中的 Streams API 详解</a>
          </li>
        
          <li>
            <a href="/2018/02/10/序列化相关/">序列化相关</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 xhlcode<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>